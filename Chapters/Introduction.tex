\part{Thesis}%
This part of the document discusses the summary of the thesis, which entails among others the research formulation and scientific contributions, followed by the research methods employed in the thesis and related works.

\chapter{Introduction}\label{chapter_introduction}
\lettrine{R}{eal-time} systems are characterized by timely computations, which are bounded by \textit{deadlines}, besides correct results of the computations~\cite{Buttazzo2003}. They are applied in many \textit{safety-critical embedded} systems, which are specialized computer systems designed for safety-critical applications~\cite{WangJiacun2017RES}, e.g., x-by-wire, flight control, industrial automation. For instance, the brake-by-wire system~\cite{Navet2010DesignSystems} applies torque proportional to the pressing of the brake pedal in order to slow down (or halt) the vehicle. Besides computing the correct torque, the system must act timely, i.e., not too soon or not too late so that a traffic accident is avoided. Therefore, safety-critical real-time systems should be analyzed for functional as well as timing correctness, and in fact, they should be analyzed rigorously according to functional safety standards, e.g., the ISO 26262 ``Road vehicles-Functional safety''~\cite{iso201126262} recommends the use of \textit{formal methods}, which are mathematical techniques and tools that enable unambiguous (or precise) specification, modeling and rigorous analysis of software and hardware systems~\cite{o2017concise}. In this thesis, we apply various formal methods early, i.e., at the requirements specification and software design levels, to improve the quality assurance of developing safety-critical embedded systems.

Over the last decades, a lot of functionality that have been realized by mechanical (or hydraulic) systems have moved to software functionality, e.g., the x-by-wire technology~\cite{Navet2010DesignSystems}, and several software functionality, which are driven by innovation and safety standards, are integrated into safety-critical systems to provide advanced, safe and reliable services, e.g., the advanced driver-assistance systems (ADAS), machine vision system for autonomous and self-driving vehicles. In response, several computing architectures have moved from a federated architecture (i.e., dedicated hardware systems executing safety-critical software systems or applications) into consolidated (i.e., multiple safety-critical software applications co-hosted on the same hardware) and distributed architectures. In distributed computing~\cite{Kopetz2003Real-timeApplications}, the safety-critical software is mapped on multiple hardware systems to capitalize on the computational power provided by the distributed architecture, e.g., the brake-by-wire software executing on multiple electronic control units (ECU) that are connected through a network bus, e.g., CAN~\cite{Davis2007ControllerRevised}. The distributed software, unlike in the case of federated computing, it is exposed to a greater degree of permanent and transient faults, therefore, reliability of the software should be maximized to improve the overall dependability of the  system. However, such measures requires additional critical system resources besides computational resources, e.g., power and energy, which are constrained in battery-driven embedded systems. Thus, the distributed safety-critical software should be deployed efficiently on the distributed architecture while meeting the timing and reliability requirements of the software.


Given this status-quo, it is beneficial to ensure the quality of most artifacts produced during the development of safety-critical embedded systems, especially when such development is based on the model-based paradigm [ref], which is the case for increasingly many industries.  Consequently, in this thesis, we propose a design approach that considers rigorous analysis and efficiency of safety-critical embedded systems by applying formal methods and optimization techniques at the early stages of software development.
 
One artifact to start with is the  requirements specification [1] that entails documenting the functional and extra-functional (e.g. timing, reliability etc.) requirements of a system in a comprehensive way. In practice, natural language
is the de facto standard for requirements specification, and quite seldom notations such as use cases, scenarios, UML diagrams, state machines. However, requirements expressed in natural language can sometimes be ambiguous,
vague, inconsistent, while intuitive to use. In order to mitigate the aforementioned problems, several approaches that involve semi-formal and formal specification methods have been investigated. Template-based approaches [take from lic thesis], such as requirements boilerplates [take from lic thesis] and property specification patterns (SPS), are semi-formal methods that use frequently reoccurring patterns, whereas other semi-formal methods rely on requirements meta-model [take from lic thesis][take from lic thesis]. The benefits of the template-based approaches are syntactic and semantic similarities to natural language with reduced ambiguity and a high degree of reuse. However, the methods are not scalable and template selection requires a lot of effort. In contrast, formal specification methods, e.g., temporal logics [take form lic thesis], Z language [take from lic thesis], etc., enable rigorous analysis but demand mathematical knowledge, which makes them not appealing to the average software engineers.
 
Due to the above, as a first contribution, we propose a constrained, yet flexible and unambiguous, natural language called ReSA, which is domain-specific and uses the notion of boilerplates to facilitate reuse. The specifications created with ReSA have semantics in Boolean logic and description logic [ref] to enable rigorous analysis via Boolean satisfiability [52] and ontology [11] methods, respectively. Therefore, as a second contribution, we propose a formal approach for analyzing ReSA specifications for logical consistency, via the two methods, which is implemented on our ReSA tool [ref our paper]. To complement the requirements modeling of an industrially-adopted architecture description language called EAST-ADL [ref], the ReSA tool is integrated seamlessly into the Eclipse-based implementation of the EAST-ADL standard, called EATOP [ref]. The language and its tool support are validated on the adjustable speed limiter use case, which is a vehicle speed control system provided by Volvo Group Trucks Technology (VGTT) in Sweden.
 
The requirements specifications are used in subsequent system development including software design to verify the latter for correct functionality. The software design is usually modeled, simulated and analyzed before implementation.
In this regard, Simulink [ref from Mathworks] is one of the most widely used development environment for multi-domain, multi-rate, discrete and continuous safety-critical systems in industry [39]. For this main reason, there is increasing
interest in the formal analysis of Simulink models [53]. Simulink Design Verifier1, which is based on the Prover technology2, is the actual tool in the Simulink environment to formally verify Simulink design models. However, it supports only discrete models, and does not offer support to verify timed properties, and high-level properties in general, such as reachability and invariance properties.
 
To address this lack, as a third contribution, we propose a scalable, formal approach for analyzing Simulink models, via statistical model checking, to verify functional and timing properties up to some probability. To automate the approach, we propose the tool SIMPPAAL [ref our TR and our FM paper - both] that uses UPPAAL Statistical Model Checker (UPPAAL SMC) [ref] as the underlying model checking engine. Our approach is pattern-based, and subsumes an execution-order preserving automatic transformation of a Simulink model into a network of stochastic timed automata that can be formally analyzed by UPPAAL SMC [29]. The statistical model checker analyzes the generated state-transition system by conducting statistical analysis on the collected traces of the system executions [13], effectively avoiding the state-space explosion of (exact) model checking [44]. To enable and ensure the correctness of the transformation, we first define the syntax and semantics of Simulink blocks and their composition, and prove the soundness of the transformation for a certain class of Simulink models. Our proposed technique is validated on the brake-by-wire use case, which is an industrial prototype provided by VGTT.
 
Due to the complexity of software that nowadays implements many system functions, several computing architectures have moved from federated architectures, that is, dedicated hardware systems executing
safety-critical software systems or applications, into consolidated and distributed architectures, with multiple safety-critical software applications co-hosted on the same hardware. In distributed computing [41], the safety-critical
software is mapped on multiple hardware systems to capitalize on the computational power provided by the distributed architecture, e.g., the brake-by-wire software executing on multiple electronic control units (ECU) that are connected through a network bus, e.g., CAN [21]. The distributed software, unlike in the case of federated computing, it is exposed to a greater degree of permanent and transient faults, therefore, reliability of the software should be maximized to improve the overall dependability of the system. However, such measures require additional critical system resources besides computational resources, e.g., energy, which are constrained in battery-driven embedded systems. Thus, the distributed safety-critical software should be mapped onto hardware effectively, to satisfy the timing and reliability requirements of the software, but also efficiently to minimize the power consumption of the distributed system. We assume that the software is scheduled using a fixed-priority preemptive policy, which is quite common in industry, and possesses end-to-end timing requirements, e.g., the time duration between the brake-pedal press and the slowdown (or halt) of the vehicle is strictly bounded. Furthermore, we consider fault tolerance as a means to maximize reliability of the distributed safety-critical software by mapping redundant software functionality on different computing units.
 
As the fourth thesis contribution, we propose exact and heuristic optimization methods, which deliver optimal and near-optimal solutions, respectively, to efficiently map the distributed safety-critical software to a network of computing nodes. Specifically, we propose a formulation of integer-linear programming (ILP) [49], which is solved using the branch and bound method. Furthermore, we propose using the hybrid-particle swarm optimization (PSO) [57], which is a meta-heuristic algorithm, to solve the shortcomings of the exact method for large-scale problems [50] with trade-off over optimality. We show how to allocate AUTOSAR software applications on a network of heterogeneous
computing nodes with respect to processor speed, failure rate and power consumption specifications, by employing both ILP and PSO . The ILP problem is implemented using ILOG CPLEX, which is a toolset for modeling and solving optimization problems. The proposed allocation methods are validated on an automotive benchmark developed according to AUTOSAR, by Bosch, Germany.

%In this thesis, we propose a design approach which considers rigorous analysis and efficiency of safety-critical embedded systems by applying formal methods and optimization techniques at the early stages of software development. Thus, the safety-critical  specifications should be unambiguous, comprehensible, etc.~\cite{ieereqspecstandard}, and the software design should conform to the specifications. Since natural language is inherently ambiguous~\cite{ieereqspecstandard}, many functional safety standards, e.g., ISO 26262, recommends semi-formal and formal specification methods to specify safety-critical embedded systems requirements, e.g., template-based languages, controlled natural language, temporal logic. The template-based specification methods, e.g., requirements boilerplates~\cite{Hull2011RequirementsEngineering}, property-specification systems~\cite{Dwyer1999PatternsVerification}, lack meta-model to effectively create templates, and is usually cumbersome to select the templates. The controlled natural languages, e.g., Attempto~\cite{attempto96}\cite{Fuchs2008AttemptoRepresentation}, etc., renders the syntax and semantics of the natural language and have formal semantics, however lacks support for embedded systems, hence are less effective. Rather, we propose a constrained natural language which is domain-specific and uses the notion of boilerplates to facilitate reuse. The specifications have semantics in Boolean logic and description logic to enable rigorous analysis via Boolean satisfiability~\cite{Malik2009BooleanSuccess} and ontology~\cite{f25ea3c6f4b743cd90c150926bbcf3db}, respectively.

%The requirements specifications are used in subsequent system development including software design to verify the latter for correct functionality. The software design is usually modeled, simulated and analyzed before implementation. In this regard, Simulink is one of the most widely used development environment for multi-domain, multi-rate, discrete and continuous safety-critical systems in industry~\cite{JamesB.Dabney2003MasteringSimulink}. For this main reason, there is increasing interest in formal analysis of Simulink models~\cite{Manamcheri2011AModels}. Simulink Design Verifier\footnote{Simulink Design Verifier - https://se.mathworks.com/products/sldesignverifier.html}, which is based on the {\sffamily\small Prover} technology\footnote{Prover - https://www.prover.com/software-solutions-rail-control/formal-verification/}, is the de~facto tool in the Simulink environment to formally verify Simulink design models. However, it has limited functionality, e.g., it supports only discrete models, has issues with scalability due to state-space explosion, and lacks verification of timed properties~\cite{Leitner2008SimulinkStudy}.  In contrast, we propose a scalable, timed analysis via a statistical model checking~\cite{Legay2010StatisticalOverview}, which uses traces of executions and statistical analysis techniques, e.g., monte-carlo simulation.

%The software design should be mapped to hardware effectively, that is satisfying the timing and reliability requirements of the distributed safety-critical software, but also efficiently to minimize the power consumption of the distributed system to facilitate accommodating complex software functionality. We assume the software is scheduled using a fixed-priority preemptive policy, which is quite common in industry, and posses end-to-end timing requirements, e.g., the time duration between the brake-pedal press and the slow-down (or halt) of the vehicle. Furthermore,  we consider fault tolerance as a means to maximize reliability of the distributed safety-critical software by mapping redundant software functionality on different computing units.  We propose  \textit{exact} and \textit{heuristic} optimization methods, which deliver optimal and near-optimal solutions, respectively, to efficiently map the distributed safety-critical software to a network of computing nodes. Specifically, we propose a formulation of integer-linear programming (\ilp)~\cite{Mahmud5222}, which is solved using branch and bound. Furthermore, we propose a hybrid-particle optimization~\cite{Mirjalili2019ParticleOptimisation}, which is a meta-heuristic algorithm, to solve the shortcomings of the exact method for large-scale problems~\cite{Mahmud2019Power-awareOptimization} with trade-off over optimality.

%The main contributions of the thesis are: 
%\begin{enumerate*}[label=(\roman*)]
%\item formal analysis of natural language requirements - we propose a fairly expressive, flexible yet structured and domain-specific constrained natural language called \textit{ReSA}~\cite{resatool}\cite{Mahmud2015ReSA:Systems}. The language has semantics in Boolean and description logic to support shallow and rigorous analysis, respectively. The Boolean specifications are checked for consistency using the Boolean satisfiability via the Z3 SMT solver.  The ReSA tool is integrated seamlessly into \eatop{} to complement the requirements modeling of \eastadl. The language and its tool support are validated on the adjustable speed limiter (\asl) use case, which is a vehicle speed control system provided by Volvo Group Trucks Technology (VGTT);

%\item scalable and formal analysis of Simulink models - we propose a pattern-based, execution-order preserving automatic transformation of a Simulink model into a network stochastic timed automata that can be formally analyzed using the UPPAAL statistical model checker (SMC)~\cite{Filipovikj2016SimulinkSystems}. The statistical model checker analyzes a state-transition system by conducting statistical analysis on the collected traces of the system executions~ \cite{Bulychev2012UPPAAL-SMC:Automata}, effectively mitigating the state-space explosion of (exact) model checking \cite{Legay2010StatisticalOverview}. Our proposed technique is validated on the brake-by-wire (BBW) use case, which is an industrial prototype provide for academic uses from VGTT;

%\item efficient allocation of distributed safety-critical software applications - we propose an integer-linear programming (\ilp) model and hybrid particle swarm optimization algorithms to allocate \autosar{} software applications on a network of heterogeneous computing nodes with respect to processor speed, failure rate and power consumption specifications. The \ilp{} problem is implemented using {\sffamily\small ILOG CPLEX}, which is a toolset for modeling and solving optimization problems. The proposed allocation methods are validated on an automotive benchmark developed according to \autosar.
%\end{enumerate*}

%\section{Thesis Outline Overview}
%The thesis is divided into two parts. The first part is a summary of our research. It is organized as follows: in Chapter 2, we give the background on the logic-based reasoning using Boolean and description logic, Simulink, \uppaal statistical model checking, and the optimization techniques based on \ilp{} and \pso. In Chapter 3, we explain the research problem and outline the research goals. The thesis contributions are discussed in Chapter 4, which states the peer-review papers mappings to the contributions. In Section 5, we provide the related work on requirements specification, formal analysis of Simulink models, and software allocation. In Chapter 6, we describe the research method applied to conduct the research. Finally, in Chapter 7, we conclude the thesis, and outline the limitation and discuss possible directions for future work.

