\part{Thesis}%
This part of the document discusses the summary of the thesis, including the research problem, goals, and scientific contributions, followed by the research methods used in the thesis, related work, and conclusions and future work.

\chapter{Introduction}\label{chapter_introduction}
\lettrine{R}{eal-time} systems are characterized by timely computations, which are bounded by \textit{deadlines}, besides correct results of the computations~\cite{Buttazzo2003}. Many embedded systems are in fact real-time systems, especially due to their safety-critical nature. Safety-critical embedded systems are specialized computer systems designed for safety-critical applications~\cite{WangJiacun2017RES}, e.g. x-by-wire, flight control, industrial control systems. For instance, the brake-by-wire system~\cite{Navet2010DesignSystems} computes a torque proportional to the brake pedal force in order to slow down (or halt) the vehicle. Besides computing the correct torque, the system must act timely, that is not too soon and not too late so that traffic accidents are avoided. Therefore, safety-critical real-time systems should be analyzed for functional as well as timing correctness. In fact, they should be analyzed rigorously according to functional safety standards, such as ISO 26262 ``Road vehicles-Functional safety''~\cite{iso201126262} that recommends the use of \textit{formal methods}, which are mathematical techniques and tools that enable unambiguous specification, modeling and analysis of software and hardware systems~\cite{o2017concise}. 

Over the last decades, a lot of functionality that has been earlier realized by mechanical (or hydraulic) systems has moved to software, e.g. via the x-by-wire technology~\cite{Navet2010DesignSystems}. Moreover, several application software programs (or user-level software functions), which are developed due to innovation and compliance to safety standards, are integrated into safety-critical systems to provide advanced, safe and reliable services, for instance, the advanced driver-assistance systems (ADAS), machine vision system for autonomous and self-driving vehicles. %In response, several computing architectures have moved from a federated architecture, that is, dedicated hardware systems executing safety-critical software systems or applications, into consolidated and distributed architectures, that is, multiple safety-critical software applications co-hosted on the same hardware and distributed architectures. In distributed computing~\cite{Kopetz2003Real-timeApplications}, the safety-critical software is mapped on multiple hardware systems to capitalize on the computational power provided by the distributed architecture, e.g. the brake-by-wire software executing on multiple electronic control units (ECU) that are connected through a network bus, e.g. CAN~\cite{Davis2007ControllerRevised}. The distributed software, unlike in the case of federated computing, it is exposed to a greater degree of permanent and transient faults, therefore, reliability of the software should be maximized to improve the overall dependability of the  system. However, such measures requires additional critical system resources besides computational resources, e.g. power and energy, which are constrained in battery-driven embedded systems. Thus, the distributed safety-critical software should be deployed efficiently on the distributed architecture while meeting the timing and reliability requirements of the software.


Given this status quo, it is beneficial to ensure the quality of most artifacts produced during the development of safety-critical embedded systems, especially when such development is based on the model-based paradigm [ref], which is the case for increasingly many industries.  Consequently, in this thesis, we propose a design approach that considers rigorous analysis and efficiency of safety-critical embedded systems by applying formal methods and optimization techniques on various artifacts produced during at the early stages of software development.
 
One artifact to start with is the requirements specification~\cite{ieereqspecstandard} that entails documenting the functional and extra-functional (e.g. timing, reliability) requirements of a system in a comprehensive way. In practice, natural language
is the de facto standard for requirements specification, and quite seldom notations such as use cases, scenarios, UML diagrams, state machines. Even if natural language is intuitive and easy to use, requirements expressed in natural language can sometimes be ambiguous, vague, inconsistent, while intuitive to use~\cite{ieereqspecstandard}. In order to mitigate the aforementioned problems, several approaches that involve semi-formal and formal specification methods have been investigated. Template-based approaches~\cite{Farfeleder2011DODT:Development}, such as requirements boilerplates~\cite{Hull2011RequirementsEngineering}\cite{Farfeleder2011DODT:Development} and property specification patterns(SPS)~\cite{Gruhn2006PatternsSpecifications}\cite{Konrad2005Real-timePatterns}, are semi-formal methods that use frequently reoccurring patterns, whereas other semi-formal methods rely on requirements meta-model~\cite{Yskout2008TransformingArchitecture}\cite{Bachmann2010ADevelopment}\cite{attempto96}\cite{Schwitter2002EnglishLanguage}. The benefits of the template-based approaches are syntactic and semantic similarities to natural language with reduced ambiguity and a high degree of reuse. However, the methods are not scalable and template selection requires a lot of effort. In contrast, formal specification methods, e.g. temporal logics~\cite{sep-logic-temporal}, Z language~\cite{ORegan2017ZLanguage}, etc., enable rigorous analysis but demand mathematical knowledge, which makes them not appealing to the average software engineers.
 
Due to the above, as a \textbf{first contribution}, we propose a constrained, yet flexible and unambiguous, natural language called \resa, which is domain-specific and uses the notion of boilerplates to facilitate reuse~\cite{Mahmud2015ReSA:Systems}. The specifications created with \resa{} have semantics in Boolean logic and description logic~\cite{Mann2014TheApplications} to enable rigorous analysis via Boolean satisfiability~\cite{Malik2009BooleanSuccess} and ontology ~\cite{f25ea3c6f4b743cd90c150926bbcf3db} methods, respectively. Therefore, as a \textbf{second contribution}, we propose a formal approach for analyzing \resa{} specifications for logical consistency, via the two methods, which is implemented in our \resa{} tool~\cite{resatool}. To complement the requirements modeling of an industrially-adopted architecture description language called \eastadl\footnote{\eastadl{} - \url{https://www.east-adl.info/index.html}}\cite{Blom2016EAST-ADL:Research}, the \resa{} tool is integrated seamlessly into the Eclipse-based implementation of the \eastadl{} standard, called \eatop\footnote{\eatop{} - \url{http://synligare.eu/Tooling.html}}. The language and its tool support are validated on the adjustable speed limiter use case, which is a vehicle speed control system provided by Volvo Group Trucks Technology (VGTT) in Sweden.
 
The requirements specifications are used in subsequent system development including software design to verify the latter for correct functionality. The software design is usually modeled, simulated and analyzed before implementation. In this regard, Simulink~\cite{JamesB.Dabney2003MasteringSimulink} is one of the most widely used development environments for multi-domain, multi-rate, discrete and continuous safety-critical industrial systems. For this main reason, there is increasing interest in the formal analysis of Simulink models~\cite{Manamcheri2011AModels}. Simulink Design Verifier\footnote{Simulink~Design~Verifier - \url{https://se.mathworks.com/products/sldesignverifier.html}} is the actual tool in the Simulink environment to formally verify Simulink design models. However, it supports only discrete models, and does not offer support to verify timed properties, and high-level properties in general, such as reachability and invariance properties.
 
To address this lack, as a \textbf{third contribution}, we propose a scalable, formal approach for analyzing Simulink models, via statistical model checking, to verify functional and timing properties up to some probability. To automate the approach, we propose the tool \simppaal~\cite{Filipovikj2016SimulinkSystems}\cite{Filipovikj4714} that uses \uppaal{} Statistical Model Checker (\uppaalsmc)~\cite{Bulychev2012UPPAAL-SMC:Automata} as the underlying model-checking engine. Our approach is pattern-based, and subsumes an execution-order-preserving automatic transformation of a Simulink model into a network of stochastic timed automata that can be formally analyzed by \uppaalsmc~\cite{Filipovikj2016SimulinkSystems}. The statistical model checker analyzes the generated state-transition system by conducting statistical analysis on the collected traces of the system executions~\cite{Legay2010StatisticalOverview}, effectively avoiding the state-space explosion of (exact) model checking. To enable and ensure the correctness of the transformation, we first define the syntax and semantics of Simulink blocks and their composition, and prove the soundness of the transformation for a certain class of Simulink models. Our proposed technique is validated on the Brake-by-Wire use case, which is an industrial prototype provided by VGTT.
 
Due to the complexity of software that nowadays implements many system functions, several computing architectures have moved from federated architectures, that is, dedicated hardware systems executing safety-critical software systems or applications, into consolidated and distributed architectures, with multiple safety-critical software applications co-hosted on the same hardware. In distributed computing~\cite{Kopetz2003Real-timeApplications}, the safety-critical
software is mapped on multiple hardware systems to capitalize on the computational power provided by the distributed architecture, e.g. the Brake-by-Wire software executing on multiple electronic control units (ECU) that are connected through a network bus, such as CAN~\cite{Davis2007ControllerRevised}. The distributed software, unlike federated computing, it is exposed to a greater degree of permanent and transient faults, therefore, the software reliability should be maximized to improve the overall dependability of the system. However, such measures require additional critical system resources besides computational resources, e.g. energy, which are constrained in battery-driven embedded systems. Thus, the distributed safety-critical software should be mapped onto hardware effectively, to satisfy the timing and reliability requirements of the software, but also efficiently to minimize the power consumption of the distributed system. We assume that the software is scheduled using a fixed-priority preemptive policy, which is quite common in industry, and possesses end-to-end timing requirements, e.g. the time duration between the brake-pedal press and the slowdown (or halt) of the vehicle is strictly bounded. Furthermore, we consider fault tolerance as a means to maximize reliability of the distributed safety-critical software by mapping redundant software functionality on different computing units.
 
As the \textbf{fourth thesis contribution}, we propose exact and heuristic optimization methods, which deliver optimal and near-optimal solutions, respectively, to efficiently map the distributed safety-critical software to a network of computing nodes. Specifically, we propose a formulation of integer linear programming (ILP) problem~\cite{Mahmud5222}, which is solved using the branch and bound method. Furthermore, we propose to solve the shortcomings of the exact method for large-scale problems [50], by using hybrid Particle Swarm Optimization (PSO)~\cite{Mirjalili2019ParticleOptimisation}, which is a meta-heuristic algorithm, with trade-off over optimality. We show how to allocate \autosar{} software applications on a network of heterogeneous computing nodes with respect to processor speed, failure rate and power consumption specifications, by employing both ILP and PSO. The ILP problem is implemented using \ilogcplex, which is a toolset for modeling and solving optimization problems. The proposed allocation approaches are validated on an automotive benchmark developed according to \autosar, by Bosch, Germany.

%In this thesis, we propose a design approach which considers rigorous analysis and efficiency of safety-critical embedded systems by applying formal methods and optimization techniques at the early stages of software development. Thus, the safety-critical  specifications should be unambiguous, comprehensible, etc.~\cite{ieereqspecstandard}, and the software design should conform to the specifications. Since natural language is inherently ambiguous~\cite{ieereqspecstandard}, many functional safety standards, e.g. ISO 26262, recommends semi-formal and formal specification methods to specify safety-critical embedded systems requirements, e.g. template-based languages, controlled natural language, temporal logic. The template-based specification methods, e.g. requirements boilerplates~\cite{Hull2011RequirementsEngineering}, property-specification systems~\cite{Dwyer1999PatternsVerification}, lack meta-model to effectively create templates, and is usually cumbersome to select the templates. The controlled natural languages, e.g. Attempto~\cite{attempto96}\cite{Fuchs2008AttemptoRepresentation}, etc., renders the syntax and semantics of the natural language and have formal semantics, however lacks support for embedded systems, hence are less effective. Rather, we propose a constrained natural language which is domain-specific and uses the notion of boilerplates to facilitate reuse. The specifications have semantics in Boolean logic and description logic to enable rigorous analysis via Boolean satisfiability~\cite{Malik2009BooleanSuccess} and ontology~\cite{f25ea3c6f4b743cd90c150926bbcf3db}, respectively.

%The requirements specifications are used in subsequent system development including software design to verify the latter for correct functionality. The software design is usually modeled, simulated and analyzed before implementation. In this regard, Simulink is one of the most widely used development environment for multi-domain, multi-rate, discrete and continuous safety-critical systems in industry~\cite{JamesB.Dabney2003MasteringSimulink}. For this main reason, there is increasing interest in formal analysis of Simulink models~\cite{Manamcheri2011AModels}. Simulink Design Verifier\footnote{Simulink Design Verifier - https://se.mathworks.com/products/sldesignverifier.html}, which is based on the {\sffamily\small Prover} technology\footnote{Prover - https://www.prover.com/software-solutions-rail-control/formal-verification/}, is the de~facto tool in the Simulink environment to formally verify Simulink design models. However, it has limited functionality, e.g. it supports only discrete models, has issues with scalability due to state-space explosion, and lacks verification of timed properties~\cite{Leitner2008SimulinkStudy}.  In contrast, we propose a scalable, timed analysis via a statistical model checking~\cite{Legay2010StatisticalOverview}, which uses traces of executions and statistical analysis techniques, e.g. monte-carlo simulation.

%The software design should be mapped to hardware effectively, that is satisfying the timing and reliability requirements of the distributed safety-critical software, but also efficiently to minimize the power consumption of the distributed system to facilitate accommodating complex software functionality. We assume the software is scheduled using a fixed-priority preemptive policy, which is quite common in industry, and posses end-to-end timing requirements, e.g. the time duration between the brake-pedal press and the slow-down (or halt) of the vehicle. Furthermore,  we consider fault tolerance as a means to maximize reliability of the distributed safety-critical software by mapping redundant software functionality on different computing units.  We propose  \textit{exact} and \textit{heuristic} optimization methods, which deliver optimal and near-optimal solutions, respectively, to efficiently map the distributed safety-critical software to a network of computing nodes. Specifically, we propose a formulation of integer-linear programming (\ilp)~\cite{Mahmud5222}, which is solved using branch and bound. Furthermore, we propose a hybrid-particle optimization~\cite{Mirjalili2019ParticleOptimisation}, which is a meta-heuristic algorithm, to solve the shortcomings of the exact method for large-scale problems~\cite{Mahmud2019Power-awareOptimization} with trade-off over optimality.

%The main contributions of the thesis are: 
%\begin{enumerate*}[label=(\roman*)]
%\item formal analysis of natural language requirements - we propose a fairly expressive, flexible yet structured and domain-specific constrained natural language called \textit{ReSA}~\cite{resatool}\cite{Mahmud2015ReSA:Systems}. The language has semantics in Boolean and description logic to support shallow and rigorous analysis, respectively. The Boolean specifications are checked for consistency using the Boolean satisfiability via the Z3 SMT solver.  The ReSA tool is integrated seamlessly into \eatop{} to complement the requirements modeling of \eastadl. The language and its tool support are validated on the adjustable speed limiter (\asl) use case, which is a vehicle speed control system provided by Volvo Group Trucks Technology (VGTT);

%\item scalable and formal analysis of Simulink models - we propose a pattern-based, execution-order preserving automatic transformation of a Simulink model into a network stochastic timed automata that can be formally analyzed using the UPPAAL statistical model checker (SMC)~\cite{Filipovikj2016SimulinkSystems}. The statistical model checker analyzes a state-transition system by conducting statistical analysis on the collected traces of the system executions~ \cite{Bulychev2012UPPAAL-SMC:Automata}, effectively mitigating the state-space explosion of (exact) model checking \cite{Legay2010StatisticalOverview}. Our proposed technique is validated on the brake-by-wire (BBW) use case, which is an industrial prototype provide for academic uses from VGTT;

%\item efficient allocation of distributed safety-critical software applications - we propose an integer-linear programming (\ilp) model and hybrid particle swarm optimization algorithms to allocate \autosar{} software applications on a network of heterogeneous computing nodes with respect to processor speed, failure rate and power consumption specifications. The \ilp{} problem is implemented using {\sffamily\small ILOG CPLEX}, which is a toolset for modeling and solving optimization problems. The proposed allocation methods are validated on an automotive benchmark developed according to \autosar.
%\end{enumerate*}

\section{Thesis Outline}
The thesis is divided into two parts. The first part is a summary of our research. It is organized as follows: in Chapter 2, we give the background on the logic-based reasoning using Boolean and description logic, Simulink, \uppaal statistical model checking, and the optimization techniques based on integer linear programming and particle swarm optimization. In Chapter 3, we explain the research problem and outline the research goals. In Chapter 4, we describe the research method applied to conduct the research. The thesis contributions are discussed in Chapter 5, which also presents the mapping of the included papers to the contributions, and of the contributions to the research goals. In Section 6, we provide the related work on requirements specification, formal analysis of Simulink models, and software allocation.  Finally, in Chapter 7, we conclude the thesis, outline the limitations and discuss possible directions for future work.

%The second part is a collection of papers included in this thesis, listed as follows:

