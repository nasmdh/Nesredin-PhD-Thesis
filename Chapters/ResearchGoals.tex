\chapter{Problem Formulation}
Over the last decades, the complexity of the safety-critical software has been on the rise which is evident on the modern cars, which implement many and complex automotive functions, and also on the emergence of the electrical and autonomous vehicles. Thus, the thesis is motivated by the need for advanced (or rigorous) methods to the requirements specification, modeling and analysis of the complex safety-critical automotive software, and their seamless integration into the existing methods and tools of the automotive systems development at VGTT and Scania. Furthermore, the thesis is motivated by the need for efficient mapping of safety-critical software to hardware in the distributed computing to facilitate software extensibiliy and support the increasing functionality of the automotive systems. 

Thus, the \textit{overall goal} of the thesis is to:
\begin{mybox}[attach title to upper={\ ---\ }]{Overall Goal}
	Provide assurance of safety-critical functionality, at the various levels of abstraction, via formal analysis, and optimization of critical system resources.
\end{mybox}

The overall goal is refined via \textit{research goals}, which state the needs or concerns that the thesis should address and are formulated as follows:

\section{Research Goals}\label{research_challenges}
Many safety-critical automotive systems are developed according to the ISO 26262 standard, which recommends highly the use of semi-formal languages to specify safety-critical requirements to improve quality of the specifications, e.g., by reducing ambiguity and improving comprehensibility. In the context of textual representations, the semi-formal specification methods are constrained natural languages, such as templates (e.g., requirements boilerplates~\cite{Farfeleder2011DODT:Development}\cite{Mahmud2015ReSA:Systems}), controlled natural languages~\cite{Kuhn2014ALanguages}(e.g., Attempto~\cite{attempto96}).

The template-based methods inherently lack meta-model (or grammar), therefore is difficult to add new templates effectively, moreover, template selection is usually cumbersome. The existing controlled natural languages lack effective support of specifying embedded systems requirements.

Thus, the first research goal is to:
\setcounter{rgcounter}{1}
\begin{researchgoal}
Reduce ambiguity and improve the comprehensibility of natural-language requirements using domain-specific knowledge of embedded systems.
\end{researchgoal}

One of the mechanisms to improve natural language specifications is by constraining the language, including its syntax, semantics and the lexicon \cite{Kuhn2014ALanguages}. The design of a constrained natural language for the specification of requirements is not trivial. By constraining the language, its expressiveness and intuitiveness can be impaired~\cite{ieereqspecstandard}\cite{Myachykov2013SyntacticRussian}, therefore, appropriate trade-offs should be made during the design in order to have a robust and effective specification language.

Besides improving quality of individual requirements, the latter should be analyzed in ensemble in order to detect errors that span multiple specifications, e.g., logical contradictions. However, natural language lacks formal (or precise and unambiguous) semantics, therefore is difficult to rigorously analyze (or reason) natural-language requirements specifications. There are several methods to natural language semantics, of which the use of \textit{logic} is common~\cite{Clark2010TheProcessing}.

Thus, the second research goal is to:
\begin{researchgoal}
Facilitate formal analysis of the requirements specifications through transformation to Boolean and description logics.
\end{researchgoal}

Natural language specifications are constructed from syntactic units, such as words, phrases, clauses, statements, etc. Consequently, rigorous analysis of the specifications involve parsing and interpreting the syntactic units, which is a complex problem in computational linguistics~\cite{Clark2010TheProcessing}. The depth of the interpretation (or semantics) greatly affects the applicability of the methods, e.g., the propositional logic representation of the specifications is simple and the analysis scales well, however, it is shallow as it abstracts away the details. On the other hand, the first-order-logic representations are more rigor, thus enable thorough analysis but are less tractable. Therefore, appropriate interpretation of the natural language specifications is crucial.

The software designs and software-design units (or behavioral models) should conform to the requirements specifications. We consider the software-design units are modeled in Simulink, which is the most widely used model-based development environment in industry to model and simulate the behavior of multi-domain, discrete, continuous embedded systems. Simulink also enables the generation of code from discrete Simulink models which directly execute on specific platforms, thus is crucial to conduct rigorous analysis of the Simulink models to reduce errors introduced in the generated code.

The de~facto Simulink analysis techniques, e.g., by type checking, simulation, and formal verification via the Simulink Design Verifier (SDV\footnote{https://se.mathworks.com/products/sldesignverifier.html}) are not sufficient to address the full correctness of safety-critical real-time Simulink models. SDV lacks support for checking temporal correctness as specified in timed properties, e.g., in TCTL, and also lacks support for verifying continuous models and suffers from scalability due to its reliance on the exact model-checking~\cite{Leitner2008SimulinkStudy}. In contrast to the exact model checking, the statistical model-checking verifies properties over sufficiently collected traces of system simulations via statistical methods. It scales better over the trade-off for exhaustiveness. 

Thus, the third research goal of the thesis is to:
\begin{researchgoal}
Enable formal analysis of large-scale, multi-rate and hybrid Simulink models using statistical model-checking.
\end{researchgoal}

Simulink consists of connected and hierarchical Simulink blocks, which encode mathematical functions~\cite{JamesB.Dabney2003MasteringSimulink}. For industrial systems, the number of blocks in a Simulink model can be in the order of thousands, and the blocks can be triggered with different sampling frequencies for discrete blocks and without any sampling frequency 
for continuous blocks. Therefore, typical industrial Simulink models are usually complex and comprise mixed signals, multiple rates, discrete and continues Simulink blocks, making the model checking challenging.

In the distributed computing, the automotive software is allocated on multiple computing units (or ECU), consequently is exposed to higher permanent and transient faults, hence necessitates to maximize the reliability of the safety-critical software system. Fault tolerance using redundancy is the most widely approach to improve reliability such as by replicating software functionality on multiple ECU, however, it requires additional critical system resources such as power sources. In this regard, the software-to-hardware allocation plays a crucial role to minimize the power consumption of fault-tolerant distributed safety-critical software while satisfying the timing and reliability constraints of the safety-critical software.

Thus, the fourth research goal is to
\begin{researchgoal}
 Minimize the power consumption of distributed safety-critical software while satisfying the timing and reliability constraints during the software allocation.
\end{researchgoal}

The software allocation model is not trivial as we consider exact method of schedulability analysis and reliability calculations, which makes the optimization complex. We assume a sufficient and necessary scheduling test based on the worst-case response time analysis~\cite{Baruah2011Response-timeSystems}\cite{Davis2007ControllerRevised}, moreover end-to-end delay analysis based on the age delay semantics~\cite{mubeen2013support}, which is practical but computationally expensive. For the reliability analysis, we apply an exact method of calculation based on the state enumeration, in contrast to the series-parallel method, which is trivial and computationally less expensive. As a result, we consider an exact optimization method using ILP for relatively small and metaheuristics for relatively large software allocation problems.

In order to show the validity of our proposed solutions, a working prototype should be developed and should also be evaluated on industrial uses cases. The validation should consider scalability and engineer-friendliness of methods and tools besides effectiveness. 

Thus, the last research goal is to:
\begin{researchgoal}
 Provide automated and engineering-friendly support for the requirements specification, software allocation of embedded  and formal analysis of Simulink models.
\end{researchgoal}

Seamless integration of our proposed methods and tools into the existing development process require close cooperation between the domain experts and the practitioners. The role of the domain experts should be to simplify usage of the tools, e.g., by rendering their interface to existing once, etc., and the practitioners should cooperate with materials that assist the validation of the proposed solutions. The cooperation is not trivial considering the challenge of formal methods, and companies culture for being restrictive.
