\subsection*{Paper A}
ReSA: An ontology-based requirement specification language tailored to automotive systems. Nesredin~Mahmud, Cristina~Seceleanu and Oscar~Ljungkrantz.\textit{In the 10th IEEE International Symposium on Industrial Embedded Systems (SIES)(pp. 1-10). IEEE, 2015}.\label{lbl_resa}\\[6pt]
\textbf{Abstract:} \textit{Automotive systems are developed using multi-leveled architectural abstractions in an attempt to manage the increasing complexity and criticality of automotive functions. Consequently, well-structured and unambiguously specified requirements are needed on all levels of abstraction, in order to enable early detection of possible design errors. However, automotive industry often relies on requirements specified in ambiguous natural language, sometimes in large and incomprehensible documents. Semi-formal requirements specification approaches (e.g., requirement boilerplates, pattern-based specifications, etc.) aim to reduce requirements ambiguity, without altering their readability and expressiveness. Nevertheless, such approaches do not offer support for specifying requirements in terms of multi-leveled architectural concepts, nor do they provide means for early-stage rigorous analysis of the specified requirements. In this paper, we propose a language, called ReSA, which allows requirements specification at various levels of abstraction, modeled in the architectural language of EAST-ADL. ReSA uses an automotive systems' ontology that offers typing and syntactic axioms for the specification. Besides enforcing structure and more rigor in specifying requirements, our approach enables checking refinement as well as consistency of requirements, by proving ordinary boolean implications. To illustrate ReSA's applicability, we show how to specify some requirements of the Adjustable Speed Limiter, which is a complex, safety-critical Volvo Trucks user function.}\\[6pt]
\textbf{Personal Contributions: }I was the main driver of the paper. I developed the ReSA language including its syntax and semantics, and Cristina Seceleanu proposed a consistency analysis technique besides giving useful comments and ideas on the design of the language. Oscar Ljungkrantz provided useful materials from VGTT that were eventually analyzed for the language development, and gave feedback on the language design and implementation from an industrial viewpoint.\\
\textbf{Status:} Published

\subsection*{Paper B}
ReSA tool: Structured requirements specification and SAT-based consistency-checking. Nesredin~Mahmud, Cristina~Seceleanu and Oscar~Ljungkrantz. \textit{In the 2016 Federated Conference on Computer Science and Information Systems (FedCSIS)(pp. 1737-1746). IEEE, 2016.}\label{lbl_resatool}\\[6pt]
\textbf{Abstract:} \textit{Most industrial embedded systems requirements are
	specified in natural language, hence they can sometimes be
		ambiguous and error-prone. Moreover, employing an early-stage
		model-based incremental system development using multiple
		levels of abstraction, for instance via architectural languages
		such as EAST-ADL, calls for different granularity requirements
		specifications described with abstraction-specific concepts that
		reflect the respective abstraction level effectively.
		In this paper, we propose a toolchain for structured requirements
		specification in the ReSA language, which scales to multiple
		EAST-ADL levels of abstraction. Furthermore, we introduce
		a consistency function that is seamlessly integrated into the
		specification toolchain, for the automatic analysis of requirements
		logical consistency prior to their temporal logic formalization
		for full formal verification. The consistency check subsumes
		two parts: (i) transforming ReSA requirements specification into
		boolean expressions, and (ii) checking the consistency of the
		resulting boolean expressions by solving the satisfiability of their
		conjunction with the Z3 SMT solver. For validation, we apply
		the ReSA toolchain on an industrial vehicle speed control system,
		namely the Adjustable Speed Limiter.}\\[6pt]%abstract
	\textbf{Personal Contributions: }I was the main driver of the paper. I developed the ReSA toolchain that consists of the editor and the consistency checker including the integration with the Z3 SAT solver in the backend. Cristina Seceleanu formulated the consistency checking and together with Oscar Ljungkrantz, they contributed to the paper with useful comments and ideas.\\
		\textbf{Status: }Published

\subsection*{Paper C}
	Specification and semantic analysis of embedded systems requirements: From description logic to temporal logic. Nesredin~Mahmud, Cristina~Seceleanu and Oscar~Ljungkrantz. \textit{In the International Conference on Software Engineering and Formal Methods (SEFM)(pp. 332-348). Springer, Cham, 2017.}\label{lbl_resadl}\\[6pt]%authors
	\textbf{Abstract:} \textit{Due to the increasing complexity of embedded systems, early detection of software/hardware errors has become desirable. In this context, effective yet flexible specification methods that support rigorous analysis of embedded systems requirements are needed. Current specification methods such as pattern-based, boilerplates normally lack meta-models for extensibility and flexibility. In contrast, formal specification languages, like temporal logic, Z, etc., enable rigorous analysis, however, they usually are too mathematical and difficult to comprehend by average software engineers. In this paper, we propose a specification representation of requirements, which considers thematic roles and domain knowledge, enabling deep semantic analysis. The specification is complemented by our constrained natural language specification framework, ReSA, which acts as the interface to the representation. The representation that we propose is encoded in description logic, which is a decidable and computationally-tractable ontology language. By employing the ontology reasoner, Hermit, we check for consistency and completeness of requirements. Moreover, we propose an automatic transformation of the ontology-based specifications into Timed Computation Tree Logic formulas, to be used further in model checking embedded systems.}\\[6pt]%abstract
	\textbf{Personal Contributions:} I was the main driver of the language. I developed the ReSA language semantics using event-base approach, which is encoded in description logic. Cristina~Seceleanu and Ljungkrantz~Oscar provided with useful ideas and comments.\\
	\textbf{Status:} Published

\subsection*{Paper D}
SIMPPAAL - A Framework For Statistical Model Checking of Industrial Simulink Models. Predrag~Filipovikj, Nesredin~Mahmud, Raluca~Marinescu, Cristina~Seceleanu, Oscar~Ljungkrantz and Henrik~L\"{o}nn. \textit{Submitted to ACM Transactions on Software Engineering and Methodology (TOSEM).}\label{lbl_simulink_ilp}
\\[3pt]{\footnotesize This article is an extended version of the following conference paper:
     Simulink to UPPAAL Statistical Model Checker: Analyzing Automotive Industrial Systems.
Predrag Filipovikj, Nesredin Mahmud, Raluca Marinescu, Cristina Seceleanu, Oscar Ljungkrantz, Henrik L{\"o}nn. In Proceedings of the 21st International
Symposium on Formal Methods (FM2016), pages 748-756. Limassol, Cyprus. Springer, LNCS, November 2016. Revisions required. }\\[6pt]%authors
	\noindent \textbf{Abstract:} \textit{The evolution of automotive systems has been rapid. Nowadays, electronic brains control dozens of functions in vehicles, like
		braking, cruising, etc. Model-based design approaches, in environments such as MATLAB Simulink, seem to help in addressing
		the ever-increasing need to enhance quality, and manage complexity, by supporting functional design from a set of block
		libraries, which can be simulated and analyzed for hidden errors, but also used for code generation. For this reason, providing
		assurance that Simulink models fulfill given functional and timing requirements is desirable. In this paper, we propose a
		pattern-based, execution-order preserving automatic transformation of atomic and composite Simulink blocks into stochastic
		timed automata that can then be formally analyzed with Uppaal Statistical Model Checker (Uppaal SMC). To enable this, we
		first define the formal syntax and semantics of Simulink blocks and their composition, and show that the transformation is
		provably correct for a certain class of Simulink models. Our method is supported by the SIMPPAAL tool, which we introduce
		and apply on two industrial Simulink models, a prototype called the Brake-by-Wire and an operational Adjustable Speed
		Limiter system. This work enables the formal analysis of industrial Simulink models, by automatically generating stochastic
		timed automata counterparts.}\\[6pt]%abstract
	\textbf{Personal Contributions: } The three co-authors contributed equally to writing the paper. Technically, I equally contributed with proposing the pattern-based semantics of Simulink blocks, together with Predrag Filipovikj. I introduced a mechanism to enforce the execution order of the blocks using inter-arrival times. Predrag implemented the flattening algorithm and the tool for the automatic transformation of Simulink models into a network of timed automata with stochastic semantics. Raluca Marinescu contributed with analyzing the BBW system, Cristina Seceleanu contributed with defining the methodology, and with useful ideas and comments. Guillermo Rodriguez-Navas wrote the related work section. The industrial coauthors provided the use cases and commented on the final draft.\\
	\noindent\textbf{Status:} Revisions required. 

\subsection*{Paper E}
Power-aware Allocation of Fault-tolerant Multirate AUTOSAR Applications.
     Nesredin~Mahmud, Guillermo~Rodriguez-Navas, Hamid~Faragardi, Saad~Mubeen and Cristina~Seceleanu. \textit{In the 25th Asia-Pacific Software Engineering Conference (APSEC'18). IEEE.}  
     \label{lbl_softwareallocation_ilp}
\\[6pt]%authors
\textbf{Abstract:} \textit{The growing complexity of automotive functionality has attracted revolutionary computing architectures such as mixed-criticality design, which enables effective consolidation of software applications with different criticality on a shared execution platform. Mixed-critical design that is required to satisfy end-to-end timing and reliability specifications should consider power-efficient software design in order to accommodate more and more functionality. Due to the recursive and exhaustive nature of the real-time and reliability analysis, exact methods, e.g., branch and bound, dynamic programming, are prohibitively expensive. We propose hybrid particle-swarm optimization algorithms based on differential evolution and hill-climbing algorithms to minimize power consumption of the safety-critical software, which have end-to-end timing and reliability requirements, on a network of heterogeneous computing units. The optimization approach employs fault tolerance to maximize reliability of the software applications subsequently meet the reliability requirements. Our proposed integrated software-allocation approach is evaluated using a range of synthetic software applications based a real-world automotive benchmark. The evaluation makes comparative analysis of the differential evolution, particle-swarm optimization, integer-linear programming and hybrid particle-swarm optimization algorithms. The results show that the hybrid algorithms based on the hill-climbing algorithms outperform the rest of the meta-heuristic algorithms, in particular, the stochastic version of the hill-climbing algorithm scales well in large software allocation optimization problems while its overall optimality performance can be deemed acceptable.
}\\[6pt]%abstract
\textbf{My Contributions: } I was the main driver of the paper. I developed the system model with the guidance of the co-authors, and formulated the optimization problem with the guidance of Hamid~Faragardi, implemented the the problem in Java, and collected and analyzed the experimental results. The co-authors gave writing updates, useful ideas and comments on the paper, and specifically: Guillermo~Rodriguez-Navas on reliability analysis, Hamid~Faragardi on optimization, Saad~Mubeen on the timing analysis and Cristina~Seceleanu on the objective function and constraints.\\
\textbf{Status:} Published

\subsection*{Paper F}
Optimized Allocation of Fault-tolerant Embedded Software with End-to-end Timing Constraints.	\textit{M\"{a}lardalen Real-time Research Center Technical Report (MRTC), ISRN MDH-MRTC-325/2019-1-SE, 2019}. Submitted to Elsevier Journal of Systems Architecture (JSA).\\[6pt]%authors
\textbf{Abstract:} \textit{It is desirable to optimize power consumption of distributed safety-critical software that realize fault tolerance and maximize reliability as a result, to support the increasing complexity of software functionality in safety-critical embedded systems. Likewise, safety-critical applications that are required to meet end-to-end timing constraints may require additional computing resources. In this paper, we propose a scalable software-to-hardware allocation based on hybrid particle-swarm optimization with hill-climbing and differential algorithms to efficiently map software components to a network of heterogeneous computing nodes while meeting the timing and reliability constraints. The approach assumes fixed-priority preemptive scheduling, and delay analysis that value freshness of data, which is typical in control software applications.
Our proposed solution is evaluated on a range of software applications, which are synthesized from a real-world automotive AUTOSAR benchmark. The evaluation makes comparative analysis of the different algorithms, and a solution based on integer-linear programming, which is an exact method. The results show that the hybrid with the hill-climbing algorithms return very close solutions to the exact method and outperformed the hybrid with the differential algorithm, though consumes more time. The hybrid with the stochastic hill-climbing algorithm scales better and its optimality can be deemed acceptable.}\\[6pt]%abstract
\textbf{Personal Contributions: } I was the main driver of the paper. I developed the system model with the guidance of the co-authors, and formulated the optimization problem with the guidance of Hamid~Faragardi, implemented the the problem in Java, and collected and analyzed the experimental results. The co-authors gave writing updates, useful ideas and comments on the paper, and specifically: Guillermo~Rodriguez-Navas on reliability analysis, Hamid~Faragardi on optimization, Saad~Mubeen on the timing analysis and Cristina~Seceleanu on the objective function and constraints. \\%my contribution
\textbf{Status:} Submitted to Journal of System Architecture (JSA), Elsevier Journals.\\
